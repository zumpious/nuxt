---
title: Upgradeleitfaden
description: 'Lernen Sie, wie Sie auf die neueste Nuxt-Version aktualisiert werden.'
navigation.icon: i-lucide-circle-arrow-up
---

## Nuxt Aktualisieren

### Neueste Ver√∂ffentlichung

Um Nuxt auf die [neueste Ver√∂ffentlichung](https://github.com/nuxt/nuxt/releases) zu aktualisieren, verwenden Sie den Befehl `nuxi upgrade`.

::code-group{sync="pm"}

```bash [npm]
npx nuxi upgrade
```

```bash [yarn]
yarn dlx nuxi upgrade
```

```bash [pnpm]
pnpm dlx nuxi upgrade
```

```bash [bun]
bun x nuxi upgrade
```

::

### Nightly Release Kanal

Um die neuesten Nuxt-Builds und Testfunktionen vor ihrer Ver√∂ffentlichung zu nutzen, lesen Sie den [Nightly Release Kanal](/docs/guide/going-further/nightly-release-channel)-Guide.

::warning
Der nightly Release Kanal `latest`-Tag ist derzeit auf die Nuxt v4-Zweig verfolgend, was bedeutet, dass es besonders wahrscheinlich Breaking Changes gibt - seien Sie vorsichtig!

Sie k√∂nnen sich auf den 3.x-Zweig nightly Releases mit `"nuxt": "npm:nuxt-nightly@3x"` eintragen.
::

## Nuxt 4 Testen

Die Ver√∂ffentlichungsdatum von Nuxt 4 ist **zu bestimmen**. Es h√§ngt davon ab, ob gen√ºgend Zeit nach der Nitro-Major Release zur vollst√§ndigen Testung im Community verf√ºgbar ist. Sie k√∂nnen den Fortschritt zur Nitro-Release in [diesem PR](https://github.com/nitrojs/nitro/pull/2521) verfolgen.

Bis zur Ver√∂ffentlichung ist es m√∂glich, viele Breaking Changes von Nuxt 4 aus Nuxt Version 3.12+ zu testen.

::tip{icon="i-lucide-video" to="https://www.youtube.com/watch?v=r4wFKlcJK6c" target="_blank"}
Schauen Sie sich ein Video von Alexander Lichter an, in dem er erkl√§rt, wie man bereits auf die Breaking Changes von Nuxt 4 eintritt.
::

### Eintritt in Nuxt 4

Zuerst aktualisieren Sie Nuxt auf die [neueste Ver√∂ffentlichung](https://github.com/nuxt/nuxt/releases).

Dann k√∂nnen Sie das `compatibilityVersion` auf den Nuxt 4 Verhaltensstand festlegen:

::note
F√ºr den Moment m√ºssen Sie den Kompatibilit√§tsversion in jeder Schicht festlegen, die auf Nuxt 4 Verhaltensstand eingehen m√∂chte. Dies wird nach der Ver√∂ffentlichung von Nuxt 4 nicht mehr erforderlich sein.
::

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  future: {
    compatibilityVersion: 4,
  },
  // Um alle Nuxt v3 Verhaltensweisen wieder zu aktivieren, setzen Sie folgende Optionen:
  // srcDir: '.',
  // dir: {
  //   app: 'app'
  // },
  // experimental: {
  //   scanPageMeta: 'after-resolve',
  //   sharedPrerenderData: false,
  //   compileTemplate: true,
  //   resetAsyncDataToUndefined: true,
  //   templateUtils: true,
  //   relativeWatchPaths: true,
  //   normalizeComponentNames: false,
  //   spaLoadingTemplateLocation: 'within',
  //   defaults: {
  //     useAsyncData: {
  //       deep: true
  //     }
  //   }
  // },
  // features: {
  //   inlineStyles: true
  // },
  // unhead: {
  //   renderSSRHeadOptions: {
  //     omitLineBreaks: false
  //   }
  // }
})
```

Wenn Sie das `compatibilityVersion` auf `4` setzen, √§ndern sich die Standardwerte in Ihrer Nuxt-Konfiguration, um auf Nuxt v4 Verhaltensstand einzugehen, aber Sie k√∂nnen bei der Testphase spezifischere Nuxt v3 Verhaltensweisen wieder aktivieren, wie in den Kommentaren oben beschrieben. Bitte melden Sie Probleme, damit wir sie in Nuxt oder im Ecosystem beheben k√∂nnen.

### Migrieren zu Nuxt 4

Breaking oder signifikante √Ñnderungen werden hier aufgef√ºhrt, zusammen mit Migrationsanweisungen f√ºr Backward/Forward Kompatibilit√§t.

::callout
Diese Abschnitt kann bis zur endg√ºltigen Ver√∂ffentlichung ge√§ndert werden, wenn Sie Nuxt 4 mit `compatibilityVersion: 4` testen, √ºberpr√ºfen Sie bitte regelm√§√üig hier.
::

#### Migrieren mit Codemods

Um den Upgradeprozess zu erleichtern, haben wir mit der [Codemod](https://github.com/codemod-com/codemod) Team zusammengearbeitet, um viele Migrationsschritte mit einigen Open-Source Codemods automatisiert zu machen.

::note
Wenn Sie Probleme haben, melden Sie sie dem Codemod Team mit `npx codemod feedback` üôè
::

F√ºr eine vollst√§ndige Liste der Nuxt 4 Codemods, detaillierte Informationen zu jedem Codemod, deren Quelle und verschiedene M√∂glichkeiten, sie auszuf√ºhren, besuchen Sie die [Codemod Registry](https://go.codemod.com/codemod-registry).

Sie k√∂nnen alle Codemods, die in diesem Leitfaden erw√§hnt werden, mit folgender `codemod` Rezeipe ausf√ºhren:

::package-managers

```bash [npm]
npx codemod@latest nuxt/4/migration-recipe
```

```bash [yarn]
yarn dlx codemod@latest nuxt/4/migration-recipe
```

```bash [pnpm]
pnpm dlx codemod@latest nuxt/4/migration-recipe
```

```bash [bun]
bun x codemod@latest nuxt/4/migration-recipe
```

::

Dieser Befehl f√ºhrt alle Codemods in Reihenfolge aus, mit der M√∂glichkeit, solche auszulassen, die Sie nicht ausf√ºhren m√∂chten. Jedes Codemod ist auch unten aufgef√ºhrt, zusammen mit seiner jeweiligen √Ñnderung, und kann unabh√§ngig ausgef√ºhrt werden.

#### Neue Verzeichnisstruktur

üö¶ **Auswirkungsniveau**: Signifikant

Nuxt verwendet jetzt eine neue Verzeichnisstruktur als Standard, mit R√ºckw√§rtskompatibilit√§t (sofern Nuxt die alte Struktur erkennt, wie z.B. mit einem obersten `pages/` Verzeichnis, wird diese neue Struktur nicht angewendet).

üëâ [Siehe vollst√§ndiges RFC](https://github.com/nuxt/nuxt/issues/26444)

##### Was ge√§ndert wurde

* Die neue Nuxt Standardverzeichnisstruktur ist `app/` als Standard, und die meisten Dinge werden von dort aus gel√∂st.
* `serverDir` ist standardm√§√üig `<rootDir>/server` anstatt `<srcDir>/server`
* `layers/`, `modules/` und `public/` werden standardm√§√üig relativ zu `<rootDir>` gel√∂st
* Wenn Sie [Nuxt Content v2.13+](https://github.com/nuxt/content/pull/2649) verwenden, ist `content/` relativ zu `<rootDir>` gel√∂st
* Ein neues `dir.app` wird hinzugef√ºgt, das das Verzeichnis ist, in dem wir `router.options.ts` und `spa-loading-template.html` suchen - dies standardm√§√üig zu `<srcDir>/`

<details>

<summary>Ein Beispiel f√ºr die v4 Verzeichnisstruktur.</summary>

```sh
.output/
.nuxt/
app/
  assets/
  components/
  composables/
  layouts/
  middleware/
  pages/
  plugins/
  utils/
  app.config.ts
  app.vue
  router.options.ts
content/
layers/
modules/
node_modules/
public/
server/
  api/
  middleware/
  plugins/
  routes/
  utils/
nuxt.config.ts
```

</details>

üëâ F√ºr weitere Details, siehe das [PR, das diese √Ñnderung implementiert](https://github.com/nuxt/nuxt/pull/27029).

##### Gr√ºnde f√ºr die √Ñnderung

1. **Leistung** - Plazieren aller Code in der Wurzel Ihres Repositorys verursacht Probleme mit `.git/` und `node_modules/` Verzeichnissen, die durch FS-Watchers durchsucht/inkludiert werden, was bei nicht-Mac OS-es einen erheblichen Startverz√∂gerung verursachen kann.
1. **IDE-Typsicherheit** - `server/` und der Rest Ihres Projekts laufen in zwei v√∂llig unterschiedlichen Kontexten, mit unterschiedlichen globalen Imports verf√ºgbar, und das Erstellen sicher, dass `server/` nicht _innerhalb_ des gleichen Verzeichnisses wie der Rest Ihres Projekts liegt, ist ein gro√üer erster Schritt, um sicherzustellen, dass Sie gute Auto-Vervollst√§ndigungen in Ihrem IDE erhalten.

##### Migrationsanweisungen

1. Erstellen Sie ein neues Verzeichnis namens `app/`.
1. Verschieben Sie Ihre `assets/`, `components/`, `composables/`, `layouts/`, `middleware/`, `pages/`, `plugins/` und `utils/` Verzeichnisse unter dieses Verzeichnis, sowie `app.vue`, `error.vue`, `app.config.ts`. Wenn Sie ein `app/router-options.ts` oder `app/spa-loading-template.html` haben, bleiben diese Pfade gleich.
1. Stellen Sie sicher, dass Ihre `nuxt.config.ts`, `content/`, `layers/`, `modules/`, `public/` und `server/` Verzeichnisse au√üerhalb des `app/` Verzeichnisses in der Wurzel Ihres Projekts bleiben.
1. Erinnern Sie sich daran, alle dritterpersonen Konfigurationsdateien an die neue Verzeichnisstruktur anzupassen, wie z.B. Ihre `tailwindcss` oder `eslint` Konfiguration (falls erforderlich - `@nuxtjs/tailwindcss` sollte `tailwindcss` korrekt konfigurieren).

::tip
Sie k√∂nnen diese Migration automatisieren, indem Sie `npx codemod@latest nuxt/4/file-structure` ausf√ºhren.
::

Allerdings ist die Migration _nicht erforderlich_. Wenn Sie Ihre aktuelle Verzeichnisstruktur beibehalten m√∂chten, sollte Nuxt diese automatisch erkennen. (Wenn dies nicht der Fall ist, melden Sie bitte ein Problem.) Eine Ausnahme ist, dass Sie bereits eine benutzerdefinierte `srcDir` haben. In diesem Fall sollten Sie sich bewusst sein, dass Ihre `modules/`, `public/` und `server/` Verzeichnisse von Ihrem `rootDir` aus, und nicht von Ihrer benutzerdefinierten `srcDir` aus, gel√∂st werden. Sie k√∂nnen dies durch Konfigurieren von `dir.modules`, `dir.public` und `serverDir` umgehen, wenn Sie dies ben√∂tigen.

Sie k√∂nnen auch die v3 Verzeichnisstruktur mit der folgenden Konfiguration erzwingen:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // Dies kehrt den neuen Standardwert von `app` zur Wurzeldirectory zur√ºck
  srcDir: '.',
  // Dies definiert den Verzeichnispr√§fix f√ºr `app/router.options.ts` und `app/spa-loading-template.html`
  dir: {
    app: 'app'
  }
})
```

#### Deduplikation von Routendaten

üö¶ **Auswirkungsniveau**: Minimal

##### Was ge√§ndert wurde

Es ist m√∂glich, einige Routendaten mithilfe von `definePageMeta` zu definieren, wie z.B. `name`, `path` und so weiter. Vorher waren diese sowohl auf der Route als auch auf Routendaten verf√ºgbar (z.B. `route.name` und `route.meta.name`).

Jetzt sind sie nur auf der Routenebene verf√ºgbar.

##### Gr√ºnde f√ºr die √Ñnderung

Dies ist ein Ergebnis der Standardaktivierung von `experimental.scanPageMeta` und ist eine Leistungsoptimierung.

##### Migrationsanweisungen

Die Migration sollte einfach sein:

```diff
  const route = useRoute()
  
- console.log(route.meta.name)
+ console.log(route.name)
```

#### Normalisierte Komponentennamen

üö¶ **Auswirkungsniveau**: Mittel

Vue generiert nun Komponentennamen, die dem Nuxt-Standard f√ºr Komponentennamen entsprechen.

##### Was ge√§ndert wurde

Standardm√§√üig, wenn Sie es nicht manuell festgelegt haben, generiert Vue einen Komponentennamen, der dem Dateinamen des Komponenten-Dateis entspricht.

```bash [Verzeichnisstruktur]
‚îú‚îÄ components/
‚îú‚îÄ‚îÄ‚îÄ SomeFolder/
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MyComponent.vue
```

In diesem Fall w√§re der Komponentennamen `MyComponent`, soweit es Vue betrifft. Wenn Sie `<KeepAlive>` damit verwenden oder ihn in den Vue DevTools identifizieren m√∂chten, m√ºssten Sie diesen Namen verwenden.

Aber um ihn automatisch zu importieren, m√ºssten Sie `SomeFolderMyComponent` verwenden.

Mit dieser √Ñnderung werden diese beiden Werte √ºbereinstimmen, und Vue generiert einen Komponentennamen, der dem Nuxt-Standard f√ºr Komponentennamen entspricht.

##### Gr√ºnde f√ºr die √Ñnderung

1. **Leistung** - Plazieren aller Code in der Wurzel Ihres Repositorys verursacht Probleme mit `.git/` und `node_modules/` Verzeichnissen, die durch FS-Watchers durchsucht/inkludiert werden, was bei nicht-Mac OS-es einen erheblichen Startverz√∂gerung verursachen kann.
1. **IDE-Typsicherheit** - `server/` und der Rest Ihres Projekts laufen in zwei v√∂llig unterschiedlichen Kontexten, mit unterschiedlichen globalen Imports verf√ºgbar, und das Erstellen sicher, dass `server/` nicht _innerhalb_ des gleichen Verzeichnisses wie der Rest Ihres Projekts liegt, ist ein gro√üer erster Schritt, um sicherzustellen, dass Sie gute Auto-Vervollst√§ndigungen in Ihrem IDE erhalten.

##### Migrationsanweisungen

Stellen Sie sicher, dass Sie den aktualisierten Namen in allen Tests, die `findComponent` aus `@vue/test-utils` verwenden, und in allen `<KeepAlive>` verwenden, die von dem Namen Ihrer Komponente abh√§ngen.

Alternativ k√∂nnen Sie f√ºr den Moment dieses Verhalten deaktivieren:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    normalizeComponentNames: false
  }
})
```

#### Unhead v2

üö¶ **Auswirkungsniveau**: Minimal

##### Was ge√§ndert wurde

[Unhead](https://unhead.unjs.io/), das zum Generieren von `<head>`-Tags verwendet wird, wurde auf Version 2 aktualisiert. Obwohl es weitgehend kompatibel ist, enth√§lt es mehrere Breaking Changes f√ºr niedrigere Ebene-APIs.

* Entfernte Props: `vmid`, `hid`, `children`, `body`.
* Promise-Eingabe wird nicht mehr unterst√ºtzt.
* Tags werden standardm√§√üig mit Capo.js sortiert.

##### Gr√ºnde f√ºr die √Ñnderung

Dies ist ein Ergebnis der Standardaktivierung von `experimental.scanPageMeta` und ist eine Leistungsoptimierung.

##### Migrationsanweisungen

Die obigen √Ñnderungen sollten minimalen Einfluss auf Ihr Projekt haben.

Wenn Sie Probleme haben, sollten Sie folgende Punkte √ºberpr√ºfen:

* Sie verwenden keine der entfernten Props.

```diff
useHead({
  meta: [{ 
    name: 'description', 
    // meta Tags ben√∂tigen keinen vmid oder eine Key    
-   vmid: 'description' 
-   hid: 'description'
  }]
})
```

* Wenn Sie [Template Params](https://unhead.unjs.io/docs/head/guides/plugins/template-params) oder [Alias Tag Sorting](https://unhead.unjs.io/docs/head/guides/plugins/alias-sorting) verwenden, m√ºssen Sie diese Funktionen explizit aktivieren.

```ts
import { TemplateParamsPlugin, AliasSortingPlugin } from '@unhead/vue/plugins'

export default defineNuxtPlugin({
  setup() {
    const unhead = injectHead()
    unhead.use(TemplateParamsPlugin)
    unhead.use(AliasSortingPlugin)
  }
})
```

W√§hrend es nicht erforderlich ist, wird empfohlen, alle Imports von `@unhead/vue` zu `#imports` oder `nuxt/app` zu aktualisieren.

```diff
-import { useHead } from '@unhead/vue'
+import { useHead } from '#imports'
```

Wenn Sie weiterhin Probleme haben, k√∂nnen Sie die v1-Verhaltensweise durch Aktivieren der `head.legacy`-Konfiguration wiederherstellen.

```ts
export default defineNuxtConfig({
  unhead: {
    legacy: true,
  }
})
```

#### Neuer DOM-Positionierung f√ºr SPA-Loading-Screen

üö¶ **Auswirkungsniveau**: Minimal

##### Was ge√§ndert wurde

Beim Erstellen einer client-only Seite (mit `ssr: false`) k√∂nnen wir optional einen Loading-Screen (aus `app/spa-loading-template.html`) innerhalb des Nuxt-App-Roots anzeigen:

```html
<div id="__nuxt">
  <!-- spa loading template -->
</div>
```

Jetzt wird standardm√§√üig der Template-Code neben dem Nuxt-App-Root angezeigt:

```html
<div id="__nuxt"></div>
<!-- spa loading template -->
```

##### Gr√ºnde f√ºr die √Ñnderung

Dies erm√∂glicht es, dass der spa Loading Template in der DOM-Struktur bis zur Aufl√∂sung des Vue-Apps Suspense bleibt, um eine wei√üe Fl√§che zu vermeiden.

##### Migrationsanweisungen

Wenn Sie den spa Loading Template mit CSS oder `document.queryElement` zielten, m√ºssen Sie Ihre Selektoren aktualisieren. Daf√ºr k√∂nnen Sie die neuen `app.spaLoaderTag` und `app.spaLoaderAttrs` Konfigurationsoptionen verwenden.

Alternativ k√∂nnen Sie die vorherige Verhaltensweise mit:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    spaLoadingTemplateLocation: 'within',
  }
})
```

#### Genauer Inline Styles

üö¶ **Auswirkungsniveau**: Mittel

Nuxt wird nun nur Styles f√ºr Vue-Komponenten, nicht f√ºr globale CSS, inl–∞–π–Ω generieren.

##### Was ge√§ndert wurde

Bisher inlanierte Nuxt generierte alle CSS, einschlie√ülich globaler Stile, und entfernte `<link>` Elemente f√ºr separaten CSS-Dateien. Jetzt generiert Nuxt dies nur f√ºr Vue-Komponenten (die fr√ºher separate CSS-Dateien produziert haben). Wir denken, dass dies eine bessere Balance zwischen Reduzierung von separaten Netzwerkanfragen (wie bisher, es gibt keine separaten Anfragen f√ºr einzelne `.css`-Dateien pro Seite oder pro-Komponente beim Initial-Load) und Erlaubnis der Caching eines einzelnen globalen CSS-Files und Reduzierung der Dokument-Download-Gr√∂√üe der Initial-Anfrage bietet.

##### Migrationsanweisungen

Diese Funktion ist vollst√§ndig konfigurierbar und Sie k√∂nnen die vorherige Verhaltensweise durch Festlegen von `inlineStyles: true` wiederherstellen, um globale CSS und per-Komponenten CSS inlaniert zu generieren.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  features: {
    inlineStyles: true
  }
})
```

#### Scan Page Meta nach Aufl√∂sung

üö¶ **Auswirkungsniveau**: Minimal

##### Was ge√§ndert wurde

Wir scannen jetzt die Routendaten (definiert in `definePageMeta`) _nach_ dem Aufrufen der `pages:extend` Hook, anstatt davor.

##### Gr√ºnde f√ºr die √Ñnderung

Dies war, um Routendaten zu scannen, die Benutzer in `pages:extend` hinzuf√ºgen wollten. Wir bieten immer noch die M√∂glichkeit, Routendaten zu √§ndern oder zu √ºberschreiben in einem neuen `pages:resolved` Hook.

##### Migrationsanweisungen

Wenn Sie Routendaten √ºberschreiben m√∂chten, tun Sie das in `pages:resolved` anstelle von `pages:extend`.

```diff
  export default defineNuxtConfig({
    hooks: {
-     'pages:extend'(pages) {
+     'pages:resolved'(pages) {
        const myPage = pages.find(page => page.path === '/')
        myPage.meta ||= {}
        myPage.meta.layout = 'overridden-layout'
      }
    }
  })
```

Alternativ k√∂nnen Sie die vorherige Verhaltensweise mit:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    scanPageMeta: true
  }
})
```

#### Shared Prerender Data

üö¶ **Auswirkungsniveau**: Mittel

##### Was ge√§ndert wurde

Wir aktivierten eine bisher experimentelle Funktion, um Daten von `useAsyncData` und `useFetch` Aufrufen zwischen verschiedenen Seiten zu teilen. Siehe [urspr√ºngliches PR](https://github.com/nuxt/nuxt/pull/24894).

##### Gr√ºnde f√ºr die √Ñnderung

Diese Funktion teilt automatisch den Payload zwischen Seiten, die vorab gerendert werden. Dies kann zu einer erheblichen Leistungsverbesserung f√ºhren, wenn Seiten, die `useAsyncData` oder `useFetch` verwenden, um dieselben Daten zu laden, vorab gerendert werden.

Zum Beispiel, wenn Ihr Site eine `useFetch` Aufrufe f√ºr jede Seite ben√∂tigt (z.B. um Navigationsinformationen f√ºr ein Men√º oder Site-Einstellungen aus einem CMS zu erhalten), w√ºrde diese Daten nur einmal beim Vorab-Rendern der ersten Seite, die sie verwendet, geladen und dann f√ºr das Vorab-Rendern anderer Seiten gespeichert werden.

##### Migrationsanweisungen

Stellen Sie sicher, dass jedes eindeutige Schl√ºssel Ihres Datenobjekts immer auf das gleiche Datenobjekt resolvbar ist. Zum Beispiel, wenn Sie `useAsyncData` verwenden, um Daten zu einem bestimmten Seite zu laden, sollten Sie einen Schl√ºssel verwenden, der das eindeutige Datenobjekt identifiziert. (`useFetch` sollte dies automatisch f√ºr Sie tun.)

```ts [app/pages/test/[slug\\].vue]
// Dies w√§re in einer dynamischen Seite (z.B. `[slug].vue`) unsicher, da der Routen-Slug die Daten abh√§ngt,
// aber Nuxt kann das nicht erkennen, da es nicht im Schl√ºssel repr√§sentiert wird.
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// Stattdessen sollten Sie einen Schl√ºssel verwenden, der das eindeutige Datenobjekt identifiziert.
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

Alternativ k√∂nnen Sie diese Funktion deaktivieren:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    sharedPrerenderData: false
  }
})
```

#### Standardwerte f√ºr `data` und `error` in `useAsyncData` und `useFetch`

üö¶ **Auswirkungsniveau**: Minimal

##### Was ge√§ndert wurde

Die `data`- und `error`-Objekte, die von `useAsyncData` zur√ºckgegeben werden, werden nun standardm√§√üig `undefined` sein.

##### Gr√ºnde f√ºr die √Ñnderung

Bisher wurde `data` auf `null` initialisiert, aber in `clearNuxtData` auf `undefined` zur√ºckgesetzt. `error` wurde auf `null` initialisiert. Diese √Ñnderung bringt gr√∂√üere Konsistenz.

##### Migrationsanweisungen

Wenn Sie √ºberpr√ºfen, ob `data.value` oder `error.value` `null` sind, k√∂nnen Sie diese √úberpr√ºfungen auf √úberpr√ºfungen auf `undefined` umstellen.

::tip
Sie k√∂nnen diesen Schritt automatisieren, indem Sie `npx codemod@latest nuxt/4/default-data-error-value` ausf√ºhren.
::

Wenn Sie Probleme haben, k√∂nnen Sie die vorherige Verhaltensweise f√ºr den Moment mit:

```ts twoslash [nuxt.config.ts]
// @errors: 2353
export default defineNuxtConfig({
  experimental: {
    defaults: {
      useAsyncData: {
        value: 'null',
        errorValue: 'null'
      }
    }
  }
})
```

Bitte melden Sie ein Problem, wenn Sie dies tun, da wir nicht planen, dies als konfigurierbar zu behalten.

#### Entfernung der deklarativen `boolean` Werte f√ºr `dedupe` Option beim Aufrufen von `refresh` in `useAsyncData` und `useFetch`

üö¶ **Auswirkungsniveau**: Minimal

##### Was ge√§ndert wurde

Es war m√∂glich, `dedupe: boolean` an `refresh` zu √ºbergeben. Diese waren Aliase von `cancel` (`true`) und `defer` (`false`).

```ts twoslash [app.vue]
// @errors: 2322
const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt!' }))

async function refreshData () {
  await refresh({ dedupe: true })
}
```

##### Gr√ºnde f√ºr die √Ñnderung

Diese Aliase wurden entfernt, um mehr Klarheit zu schaffen.

Das Problem trat auf, als `dedupe` als Option zu `useAsyncData` hinzugef√ºgt wurde, und wir die boolean-Werte entfernten, da sie sich zu _Gegenpolen_ entwickelt hatten.

`refresh({ dedupe: false })` bedeutete 'besteht nicht auf der _Abbrechung_ bestehender Anfragen im Vorteil der neuen Anfrage'. Aber `dedupe: true` innerhalb der Optionen von `useAsyncData` bedeutete 'mache keine neuen Anfragen, wenn es bereits eine pendente Anfrage gibt.' (Siehe [PR](https://github.com/nuxt/nuxt/pull/24564#pullrequestreview-1764584361).)

##### Migrationsanweisungen

Die Migration sollte einfach sein:

```diff
  const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt 3!' }))
  
  async function refreshData () {
-  